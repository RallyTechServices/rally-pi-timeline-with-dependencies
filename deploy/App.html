<!DOCTYPE html>
<html>
<head>
    <title>Timeline With Dependencies</title>
    <!--  (c) 2014 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Tue Feb 18 2014 20:42:28 GMT-0800 (PST) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Tue Feb 18 2014 20:42:28 GMT-0800 (PST)";
        var CHECKSUM = 78481437504;
    </script>
    
    <script type="text/javascript" src="/apps/x/sdk.js"></script>
    <script type="text/javascript" src="/slm/js-lib/ext-gantt/2.2.15/gnt-all.js"></script>
    <script type="text/javascript" src="/slm/js/alm/src/ui/timeline/TaskModelFactory.js"></script>

    <!-- 
    <script type="text/javascript" src="/slm/js/alm/src/ui/timeline/Timeline.js"></script>
    -->
    <script type="text/javascript" src="/slm/js/alm/src/ui/timeline/PrintTimelineTemplate.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
/**
 * The timeline component.
 */
Ext.define('Rally.alm.ui.timeline.Timeline', {
    alias:"widget.almtimeline",
    extend: 'Gnt.panel.Gantt',
    
    requires: [
        'Sch.util.Date',
        'Sch.preset.Manager',
        'Rally.ui.renderer.RendererFactory',
        'Rally.alm.ui.timeline.TaskModelFactory',
        'Gnt.plugin.Printable'
    ],

    bubbleEvents:['add','remove','zoom'],

    statics:{
        errorMessages:{
            missingTreeColumn:  "Timeline component requires that at least one column in the config is of xtype treecolumn",
            columnMustBeAnArray:  "Timeline component requires columns to be sent into the config as an array"
        }
    },

    clientMetrics: {
        beginEvent: 'added',
        endEvent: 'load',
        description: 'timeline loaded'
    },

    itemId: 'rallyTimeline',
    height: 350,
    width: '100%',
    highlightWeekends: false,
    loadMask: true,
    config: {
        /**
         * @cfg {String} viewPreset A key used to lookup a predefined Sch.preset.ViewPreset (e.g. 'weekAndDay', 'hourAndDay'), managed by Sch.preset.Manager. See Sch.preset.Manager for more information.
         * Do not use this, use zoomLevel instead.
         */

        /**
         * @cfg {String} leftLabelField The field that will be displayed to the left of each bar can be deleted to have the component show no fields.
         * This field will be used to find the renderer off of the model if possible to render the field properly.
         */
        leftLabelField:"_refObjectName",

        /**
         * @cfg {String} rightLabelField The field that will be displayed to the right of each bar. Can be deleted to have the component show nothing.
         * This field will be used to find the renderer off of the model if possible to render the field properly.
         */

        /**
         * @cfg {String}
         * The date field that will be used for the left border of the item's time representation.
         */
        startDate: Sch.util.Date.add(new Date(), Sch.util.Date.MONTH, -3),

        /**
         * @cfg {String}
         * The date field that will be used for the right border of the item's time representation.
         */
        endDate: Sch.util.Date.add(new Date(), Sch.util.Date.YEAR, 1),

        /**
         * @cfg {Boolean} showTodayLine
         * Controls whether or not a vertical line is shown at today's date
         */
        showTodayLine: true,

        /**
         * @cfg {String} startDateField
         * The date field to determine the start of the task bar
         */

        /**
         * @cfg {String} endDateField
         * The date field to determine the end of the task bar
         */

        /**
         * @cfg {Number} baselinePercentDoneField
         * The date field to determine the percent done for the task bar
         */

        /**
         * @cfg {String} baselineStartDateField
         * The date field to determine the start of the baseline bar
         */

        /**
         * @cfg {String} baselineEndDateField
         * The date field to determine the end of the baseline bar
         */

        /**
         * @cfg {Number} percentDoneField
         * The field that will be used for the percent done portion of the item's time representation.
         */

        /**
         * @cfg {Boolean} toggleParentTasksOnClick
         * Whether or not clicking on timeline bars causes a hierarchcy expand/collapse
         */
        toggleParentTasksOnClick: false,

        /**
         * @cfg {String} childCountField
         * The field from which to determine whether an item has children
         */
        childCountField: 'Children',

        /**
         * @cfg {Number/String}
         * The default zoom level.  Either a string or an index into the Rally.alm.ui.timeline.Timeline#zoomLevels array.
         */
        zoomLevel: 'rallyWeekAndMonth',

        /**
         * @cfg {Object[]}
         * The zoom levels that are supported by Rally.alm.ui.timeline.Timeline#zoom.
         * See Sch.preset.Manager for valid values.
         */
        zoomLevels: [
            { width: 30,    increment: 1,   resolution: 1, preset: 'year', resolutionUnit: 'MONTH' },
            { width: 100,   increment: 1,   resolution: 7, preset: 'monthAndYear', resolutionUnit: 'DAY'},
            { width: 50,    increment: 1,   resolution: 1, preset: 'rallyWeekAndMonth', resolutionUnit: 'DAY'}
        ]
    },

    plugins: new Gnt.plugin.Printable(),

    constructor: function(config) {
        this.initConfig(config);

        //adjust end date for using ie to add an additional week for layout
        this._adjustEndDateForIERendering();

        this._createRallyDefaultViewPreset();

        if (!config.columns) {
            config.columns = this.getDefaultColumns(config.taskStoreConfig.model);
        }

        this.zoomLevel = this._resolveZoomLevel(this.zoomLevel);

        config.viewPreset = this.zoomLevel.preset;

        var taskStoreConfig = Ext.apply({
            autoLoad: true,
            sorters: [
                {
                    property: 'Name',
                    direction: 'DESC'
                }
            ],
            listeners: {
                load: this._onLoaded,
                scope: this
            },
            recalculateParents: false
        }, config.taskStoreConfig);

        taskStoreConfig.model = Rally.alm.ui.timeline.TaskModelFactory.getTaskModel({
            wsapiModel: taskStoreConfig.model
        });

        console.log("taskStoreConfig ",taskStoreConfig);
        
        var taskStore = Ext.create("Gnt.data.TaskStore", taskStoreConfig);
        taskStore.on('load', this._onLoaded, this);

        config.taskStore = taskStore;

        this._validateColumns(config.columns);

        if (config.leftLabelField) {
            config.leftLabelField = this._generateLabelFieldConfig(this.config.leftLabelField, config.taskStore.model);
        }
        if (config.rightLabelField) {
            config.rightLabelField = this._generateLabelFieldConfig(this.config.rightLabelField, config.taskStore.model);
        }

        if (config.baselineStartDateField && config.baselineEndDateField) {
            config.enableBaseline =  true;
            config.baselineVisible = true;
        }

        this.callParent(arguments);
    },

    _resolveZoomLevel: function(zoomLevel) {
        var resolvedZoomLevel;

        if(_.isObject(zoomLevel)) {
            resolvedZoomLevel = zoomLevel;
        }

        if(_.isNumber(zoomLevel)) {
            resolvedZoomLevel = this.zoomLevels[zoomLevel];
        }

        if(_.isString(zoomLevel)) {
            resolvedZoomLevel = _.find(this.zoomLevels, { preset: zoomLevel });

        }

        return resolvedZoomLevel || this.zoomLevels[2];
    },

    _adjustEndDateForIERendering: function() {
        //IE hack to handle crap display when 1st of the month is on or after Thursday not past the first Sunday of the month
        var endDateCalendarDay = this.endDate.getDate();
        var endDateDayOfWeek = this.endDate.getDay();
        if (endDateCalendarDay <= 4 && (endDateDayOfWeek < 2 || endDateDayOfWeek > 4)) {
            var addWeek = false;
            switch (endDateDayOfWeek) {
                case 5: //Friday
                    addWeek = (endDateCalendarDay < 2);
                    break;
                case 6: //Saturday
                    addWeek = (endDateCalendarDay < 3);
                    break;
                case 0: //Sunday
                    addWeek = (endDateCalendarDay < 4);
                    break;
                case 1: //Monday
                    addWeek = (endDateCalendarDay !== 1);
                    break;
            }
            if (addWeek) {
                this.endDate = Sch.util.Date.add(this.endDate, Sch.util.Date.DAY, 7);
            }
        }
    },

    initComponent: function() {
        this.callParent(arguments);

        this.addEvents([
           /**
            * @event
            * Fires when a zoom has completed
            * @param {Rally.alm.ui.timeline.Timeline} this
            * @param {Number} zoomLevel The new zoom level
            */
            'zoom',
            /**
             * @event
             * Fires after the timeline has loaded
             * @param {Rally.alm.ui.timeline.Timeline} this
             */
            'afterload'
        ]);
    },

    /**
     * Set the Timeline's zoom level
     * @param {Number/String} zoomLevel A number between 0 and length of Rally.alm.ui.timeline.Timeline#zoomLevels - 1.
     * This number will be used to index the Rally.alm.ui.timeline.Timeline#zoomLevels array.
     * Alternatively, you can pass in a string element in the Rally.alm.ui.timeline.Timeline#zoomLevels array.
     */
    zoom: function(zoomLevel){
        zoomLevel = this._resolveZoomLevel(zoomLevel);
        this.switchViewPreset(zoomLevel.preset, this.startDate, this.endDate);
        if(this.getStore().getCount() > 0){
            this._scrollNearToday();
        }
        this.zoomLevel = zoomLevel;
        this.fireEvent('zoom', zoomLevel);
    },

    _onLoaded: function(taskStore, model, records) {
        if (this.isVisible()) {
            this._ieFixHeaderWidthComputeIssue();

            this.suspendEvents();
            this.zoom(this.zoomLevel);
            this.resumeEvents();

            if(records.length < 1){
                //empty message is to the left, scroll there if we don't have any records
                this.getSchedulingView().getEl().scrollTo('left', 0);
            }

            //slim down the space between the tree and the timeline
            this.down('bordersplitter').setWidth(2);

            if(records.length >= 1) {
                this._scrollNearToday();
            }

            this.fireEvent('afterload');
        }
    },

    _scrollNearToday: function(){
        this.scrollToDate(Rally.util.DateTime.add(new Date(), 'day', -14));
    },

    _getViewportLeftDate: function() {
         var schedulingView = this.getSchedulingView();
         var scroll = schedulingView.getEl().getScroll();

         var xCoordinate = [scroll.left, 0];
         return schedulingView.getDateFromXY(xCoordinate, null, true);
     },

    show: function() {
        this._ieFixHeaderWidthComputeIssue();
        this.callParent(arguments);
    },

    _ieFixHeaderWidthComputeIssue: function() {
        if (Ext.isIE) {
            var svTimeaxisHdr = this.getEl().down('.sch-timeaxiscolumn');
            if (svTimeaxisHdr) {
                var svHdr = svTimeaxisHdr.up('div');
                if (svHdr) {
                    var svHdrWidth = svHdr.dom.style.width;
                    if (svHdrWidth) {
                        if (svTimeaxisHdr.dom.style.width && svTimeaxisHdr.dom.style.width !== svHdrWidth) {
                            svTimeaxisHdr.dom.style.width = svHdrWidth;
                        }
                        var hdrTable = svHdr.down('table');
                        if (hdrTable.dom.style.width && hdrTable.dom.style.width !== svHdrWidth) {
                            hdrTable.dom.style.width = svHdrWidth;
                        }
                    }
                }
            }
        }
    },

    // Setup your static columns
    /**
     * @return {Object} Returns the set of default columns for a timeline
     */
    getDefaultColumns: function(model) {
        var nameField = model.getField("Name");
        if (nameField) {
            return [
                {
                    xtype : 'treecolumn',
                    header:"Name",
                    dataIndex: 'Name',
                    width: 200,
                    menuDisabled: true
                }
            ];
        }
        else {
            return [
                {
                    xtype : 'treecolumn',
                    header:"Name",
                    dataIndex: '_refObjectName',
                    width: 200
                }
            ];
        }
    },

    //checks to make sure that a tree column is specified.
    _validateColumns:function(columns) {
        if (!Ext.isArray(columns)) {
            throw this.self.errorMessages.columnMustBeAnArray;
        }
        var types = Ext.Array.pluck(columns, "xtype");
        if (Ext.Array.indexOf(types, "treecolumn") == -1) {
            throw this.self.errorMessages.missingTreeColumn;
        }
    },

    _generateLabelFieldConfig:function(labelField, model) {
        if (Ext.isString(labelField)) {
            return {
                dataIndex:labelField,
                renderer:function(value, record) {
                    var template = Rally.ui.renderer.RendererFactory.getRenderTemplate(model.getField(labelField));
                    return template.apply(record.data);
                }
            };
        }
        return labelField;
    },

    _createRallyDefaultViewPreset: function() {
        var curContext = Rally.environment.getContext();
        var userDateFormat = curContext.getUser().UserProfile.DateFormat ||
                curContext.getWorkspace().WorkspaceConfiguration.DateFormat;

        var config = {
            timeColumnWidth : 100,
            rowHeight: 24,          // Only used in horizontal orientation
            resourceColumnWidth : 100,  // Only used in vertical orientation
            displayDateFormat : 'Y-m-d',
            shiftUnit : "WEEK",
            shiftIncrement : 5,
            defaultSpan : 6,       // By default, show 6 weeks
            timeResolution : {
                unit : "DAY",
                increment : 1
            },
            headerConfig : {
                middle : {
                    unit : "WEEK",
                    renderer : function(start, end, cfg) {
                        return Rally.util.DateTime.format(start, userDateFormat);
                    }
                },
                top : {
                    unit : "MONTH",
                    dateFormat : 'M Y'
                }
            }
        };
        Sch.preset.Manager.registerPreset('rallyWeekAndMonth', config);
    }
});
Ext.define('DependencyTimeline',{
    extend: 'Rally.alm.ui.timeline.Timeline',
    alias:"widget.tsdependencytimeline",
    constructor: function(config) {
        this.initConfig(config);
 

        var dependencyStore = Ext.create("Gnt.data.DependencyStore", {
            autoLoad    : true,
            proxy       : {
                type    : 'memory',
                reader  : {
                    type: 'json'
                },
                data: [ ]
            }
        });
        
        this.dependencyStore = config.dependencyStore = dependencyStore;
        
        this.callParent(arguments);
    },
    _onLoaded: function(taskStore, model, records) {
        var me = this;
        Ext.Array.each(records, function(record) { record.set('Id',record.get('ObjectID')) ; } );
        
        var promises = [];
        Ext.Array.each(records, function(record) {
            var object_id = record.get('ObjectID');
            record.set('Id',object_id);
            promises.push(me._getDependencies(object_id));
        });

        Deft.Promise.all(promises).then({
            scope: this,
            success: function(records) {
                var dependencies = Ext.Array.flatten(records);
                this.dependencyStore.loadRawData(dependencies);
            },
            failure: function(error) {
                alert(error);
            }
        });
        this.callParent(arguments);
    },
    _getDependencies: function(object_id){
        var deferred = Ext.create('Deft.Deferred');
        Ext.create('Rally.data.wsapi.Store',{
            autoLoad: true,
            model:'UserStory',
            filters: [{property:'Feature.ObjectID',value:object_id}],
            fetch: ['ObjectID','Predecessors','Feature'],
            listeners: {
                scope: this,
                load: function(store,stories) {
                    var me = this; 
                    var promises = [];
                    Ext.Array.each(stories, function(story) {
                        if ( story.get('Predecessors').Count != 0 ) {
                            promises.push(me._getCollectionFromRecord(story,'Predecessors'));
                        }
                    });
                    if ( promises.length > 0 ) {
                        Deft.Promise.all(promises).then({
                            scope: this,
                            success: function(records) {
                                deferred.resolve(records);
                            },
                            failure: function(error) {
                                deferred.reject(error);
                            }
                        });
                    } else {
                        deferred.resolve([]);
                    }
                }
            }
        });
        return deferred.promise;
    },
    _getCollectionFromRecord: function(story,field_name) {
        var deferred = Ext.create('Deft.Deferred');
        story.getCollection(field_name).load({
            fetch: ['Feature','ObjectID'],
            callback: function(predecessors,operation,success){
                var dependencies = [];
                Ext.Array.each(predecessors,function(predecessor){
                    if ( predecessor.get('Feature') ) {
                        dependencies.push({
                            "From":predecessor.get('Feature').ObjectID,
                            "To"  :story.get('Feature').ObjectID,
                            "Type":3
                        });
                    }
                });
                deferred.resolve(dependencies);
            }
        });        
        return deferred.promise;
    }
});
/**
 * The portfolio item timeline component with type filter.
 */
Ext.define('Rally.alm.ui.timeline.PortfolioItemTimeline', {
    extend:'Ext.container.Container',
    requires:[
        'Rally.util.DateTime',
        'Rally.util.Test',
        'Rally.ui.ButtonSlider',
        'Rally.util.HealthColorCalculator',
        'Rally.ui.EmptyTextFactory',
        'Rally.alm.ui.timeline.Timeline',
        'DependencyTimeline'
    ],
    alias: 'widget.almportfolioitemtimeline',

    clientMetrics: [
        {
            event: 'beforeexpandnode',
            description: 'PI timeline node expanded'
        }
    ],

    config:{
        estimatedStartDateField:"PlannedStartDate",
        estimatedEndDateField:"PlannedEndDate",
        actualStartDateField:"ActualStartDate",
        actualEndDateField:"ActualEndDate",
        childCountField:'DirectChildrenCount',
        piTypeField:'PortfolioItemType',
        piTypeOrdinalValueField:'Ordinal',

        /**
         * @cfg {Boolean} fullScreen tell the component to monitor window resize events and resize to fill all available space
         */
        fullScreen:false,
        /**
         * @cfg {String} type The current PortfolioItem Type that will be shown
         */
        /**
         * @cfg {String} The current zoom level that will be shown.
         */
        zoomLevel:'monthAndYear',
        /**
         * @cfg {String}
         * the type to default the type dropdown to
         */
        type: undefined,

        /**
         * @cfg {String}
         * the optional query - allows a custom query to be added to filters sent to the WSAPI proxy
         */
        customQueryString: ''
    },

    zoomLevels: ['year', 'monthAndYear', 'rallyWeekAndMonth'],

    emptyTextTpl: ['<p>There are no {selectedType}(s) with current dates. <a href="#/portfolioitems">Manage Portfolio Items</a></p>',
        '<p>Rally Portfolio Manager allows you to plan and track longer-term initiatives, ',
        'with actual progress information rolling up from development teams. ',
        '{[Rally.alm.util.Help.getLinkTag({id: "224", text: "Learn more"})]} ',
        'about configuring Rally Portfolio Manager and best practices for creating Portfolio Items.</p>'],

    constructor: function(config) {

        this.config.taskStoreConfig = {
            startDate: Rally.util.DateTime.add(new Date(), Ext.Date.YEAR, -1),
            endDate: Rally.util.DateTime.add(new Date(), Ext.Date.YEAR, 1),
            skipWeekendsDuringDragDrop:false,
            weekendsAreWorkdays:true,
            sorters:[
                {
                    property:'Rank',
                    direction:'ASC'
                }
            ]
        };

        var conf = Ext.merge({}, this.config, config);

        this.initConfig(conf);
        this.callParent([conf]);
    },

    initComponent:function () {
        this.callParent(arguments);
        this.addEvents(
            /**
             * @event
             * Fires when the timeline has loaded.
             * @param {Rally.alm.ui.timeline.PortfolioItemTimeline} this
             */
            'load',
            /**
             * @event
             * Fires when the type combobox changes.
             * @param {Rally.alm.ui.timeline.PortfolioItemTimeline} this
             */
            'typeChange'
        );
        this.on('afterrender', this._onAfterRender, this);

        if (this.getFullScreen()) {
            Ext.EventManager.onWindowResize(this._resizeTimelineToFit, this);
        }
    },

    /**
     * Resize the timeline to fill the available area when the window resizes
     */
    _resizeTimelineToFit:function (windowWidth, windowHeight) {

        /* don't let the timeline shrink away to nothing on small resolutions */
        var minHeight = 250;

        if (!this.timeline || !this.timeline.el) {
            return;
        }

        if (!Ext.isDefined(windowWidth)) {
            windowWidth = Ext.getBody().getWidth();
        }
        if (!Ext.isDefined(windowHeight)) {
            windowHeight = Ext.getBody().getHeight();
        }

        var timelineRegion = Ext.util.Region.getRegion(this.timeline.el);

        var legendHeight = this.down('#timelineLegend').getHeight();

        //need to know the footer height to know how much space we have
        var footerHeight = Ext.get('footer').getHeight();
        var devFooter = Ext.get('devFooter');
        if (devFooter) {
            footerHeight += devFooter.getHeight();
        }

        var height = windowHeight - timelineRegion.top - legendHeight - footerHeight;

        if (height < minHeight) {
            height = minHeight;
        }

        this.timeline.setHeight(height);

        this.timeline.setWidth(windowWidth - 20);

    },

    _onAfterRender:function () {
        this.typeComboBox = this._createTypeComboBox();

        this.getEl().on('click', function (event, el) {
            el = Ext.get(el);
            var record = this._getRecordFor(el, this.timeline.getSchedulingView());
            Ext4.create('Rally.ui.popover.PercentDonePopover', {
                target: el,
                percentDoneData: record.data,
                percentDoneName: 'PercentDoneByStoryCount',
                piRef: record.data._ref,
                viewportPadding: [15,25,15,215]
            });
        }, this, {
            delegate: '.sch-gantt-baseline-item'
        });
    },

    _onModelsRetrieved:function (models) {
        this.models = models;
        this._createHeader();
        this._updateTimelineData();
        this._createLegend();
    },

    _createHeader: function(){
        var items = [{
            xtype: 'component',
            flex: 1
        }];

        items = items.concat(this._createZoomComponentItems());

        items.push(this.typeComboBox);

        var header = Ext.create('Ext.container.Container', {
            itemId: 'timelineHeader',
            items: items,
            layout: {
                type: 'hbox',
                align: 'middle'
            }
        });

        this.add(header);
    },

    _createLegend: function(){

        var tpl = Ext.create('Ext.XTemplate',
                '<b><span class="legend-text">Legend</span></b>',
                '<div><span class="legend-item planned"></span><span class="legend-text">Planned</span></div>',
                '<div><span class="legend-item" style="background-color: {late-color}"></span><span class="legend-text">Late</span></div>',
                '<div><span class="legend-item" style="background-color: {at-risk-color}"></span><span class="legend-text">At Risk</span></div>',
                '<div><span class="legend-item" style="background-color: {on-track-color}"></span><span class="legend-text">On Track</span></div>',
                '<div><span class="legend-item" style="background-color: {complete-color}"></span><span class="legend-text">Complete</span></div>'
        );

        this.add({
            xtype: 'component',
            itemId: 'timelineLegend',
            cls: 'timelineLegend',
            renderTpl: tpl,
            renderData: {
                'late-color': Rally.util.HealthColorCalculator.colors.red.hex,
                'at-risk-color': Rally.util.HealthColorCalculator.colors.yellow.hex,
                'on-track-color': Rally.util.HealthColorCalculator.colors.green.hex,
                'complete-color': Rally.util.HealthColorCalculator.colors.gray.hex
            }
        });
    },

    _createZoomComponentItems: function() {
        return [
            {
                xtype: 'label',
                text: 'Zoom',
                cls: 'rui-label'
            },
            {
                xtype: 'rallybuttonslider',
                cls: 'zoom-component',
                itemId:'zoomButtonSlider',
                sliderConfig:{
                    value:this.getSliderValueFromZoom(this.getZoomLevel()),
                    increment:1,
                    minValue:0,
                    maxValue:this.zoomLevels.length-1,//0 based
                    useTips:false,
                    listeners:{
                        change:function (slider, newValue) {
                            this.zoom(newValue);
                        },
                        scope: this
                    }
                }
            }
        ];
    },

    /**
     * Sets the zoom slider without firing the changed event
     * @param zoom{Number/String}
     */
    setZoomSliderValue:function(zoom){
        if (!this.rendered) {
            return;
        }
        var zoomIndex = Ext.isString(zoom)?this.getSliderValueFromZoom(zoom):zoom;
        var slider = this.down("#zoomButtonSlider");
        if (!slider) {
            return;
        }

        var originalValue = slider.getValue();

        slider.suspendEvents();
        slider.setValue(zoomIndex);
        slider.resumeEvents();

        if(originalValue === slider.getValue()){
            this.zoom(zoomIndex);
        }

    },

    setZoomLevel: function (zoomLevel) {
        this.zoomLevel = zoomLevel || this.getDefaultZoomLevel();
        this.setZoomSliderValue(this.zoomLevel);
    },

    getZoomLevel: function () {
        return this.zoomLevel || this.getDefaultZoomLevel();
    },
    _createTypeComboBox: function() {        
        var typeComboBox = Ext.create('Ext.container.Container',{ tpl: " <tpl>{Name}</tpl>"});
        
        Ext.create('Rally.data.wsapi.Store',{
            model: 'TypeDefinition',
            sorters:{
                property:'Ordinal',
                direction:'Asc'
            },
            limit: 1,
            pageSize: 1,
            filters: [
                {
                    property: 'Parent.Name',
                    operator: '=',
                    value: 'Portfolio Item'
                },
                {
                    property: 'Creatable',
                    operator: '=',
                    value: 'true'
                }
            ],
            autoLoad: true,
            listeners: {
                scope: this,
                load: function(store, types){
                    var selectedType = types[0];
                    
                    var typeNames = [];
                    Ext.each(types, function(value) {
                        typeNames.push(value.get('TypePath'));
                    });
                    
                    Rally.data.ModelFactory.getModels({
                        types : typeNames,
                        context: this.context,
                        success: this._onModelsRetrieved, scope:this
                    });
                    
                    typeComboBox.update(selectedType.getData());
                    typeComboBox.getRecord = function() { return selectedType; };
                    typeComboBox.getValue = function() { return typeNames[0]; };                    
                }
            }
        });
        
        return typeComboBox;
    },

    _getTypeRecordFromComboBox: function() {
        return this.typeComboBox.getRecord();
    },

    _onTypeSelect:function(){
        this.fireEvent('typeChange', this.getSelectedType());
        this._updateTimelineData();
    },

    _updateTimelineData: function() {
        if (this.timeline) {
            this.timeline.hide();
            this.timeline.destroy();
        }
        this._createTimeline();
    },

    _createTimeline: function() {
        //this.timeline = Ext.create('Rally.alm.ui.timeline.Timeline', this._getTimelineConfig());
        this.timeline = Ext.create('DependencyTimeline', this._getTimelineConfig());
        window.tl=this.timeline;
        this.insert(1, this.timeline);
    },

    _buildFilter:function () {
        var filters = [
            {
                property:this.estimatedStartDateField,
                operator:'!=',
                value:'null'
            },
            {
                property:this.estimatedEndDateField,
                operator:'!=',
                value:'null'
            },
            {
                property:this.estimatedEndDateField,
                operator:'>=',
                value:Rally.util.DateTime.format(this.taskStoreConfig.startDate, 'yyyy-MM-dd')
            },
            {
                property:this.estimatedStartDateField,
                operator:'<=',
                value:Rally.util.DateTime.format(this.taskStoreConfig.endDate, 'yyyy-MM-dd')
            },
            this._getTypeFilter()
        ];

        if (this.customQueryString) {
            try {
                filters.push(Rally.data.wsapi.Filter.fromQueryString(this.customQueryString));
            } catch (e) {
                Rally.ui.notify.Notifier.showError({
                    message: e.message
                });
            }
        }

        return filters;
    },

    _buildDrillDownFilter:function () {
        return [{
            property:'Parent',
            operator:'=',
            value:Rally.util.Ref.getRelativeUri(this._expandedNode.get('_ref'))
        }];
    },

    _getCurrentFilter:function () {
        return this._expandedNode ? this._buildDrillDownFilter() : this._buildFilter();
    },

    _getCurrentFetch:function () {
        var fetch = [
            'Name',
            this.estimatedStartDateField,
            this.estimatedEndDateField,
            this.actualStartDateField,
            this.actualEndDateField,
            this.piTypeField,
            this.piTypeOrdinalValueField,
            'Workspace',
            'FormattedID',
            'PercentDoneByStoryCount',
            'PercentDoneByStoryPlanEstimate'
        ];


        var record = !this._expandedNode ? this._getTypeRecordFromComboBox() : this._getTypeRecordBelowCurrentlyExpandedNode();
        if(record && record.get(this.piTypeOrdinalValueField) > 0) {
            fetch.push(this.childCountField);
        }

        return fetch;
    },


    _getTypeRecordAtOrdinal: function(ordinal) {
       return this.typeComboBox.findRecord(this.piTypeOrdinalValueField, ordinal);
    },

    _getTaskModelForExpandedType: function() {
        return Rally.alm.ui.timeline.TaskModelFactory.getTaskModel({
            wsapiModel: this._getModelBelowExpandedNode()
        });
    },

    _getModelBelowExpandedNode: function() {
        return this._getModelForTypeRecord(this._getTypeRecordBelowCurrentlyExpandedNode());
    },

    _getModelForTypeRecord: function(record) {
        console.log("models ",this.models);
        return this.models[record.get('TypePath')];
    },

    _getModelForCurrentType: function() {
        return this._getModelForTypeRecord(this._getTypeRecordFromComboBox());
    },

    _getTypeRecordBelowCurrentlyExpandedNode : function() {
        return this._getTypeRecordAtOrdinal(this._getCurrentlyExpandedNodeOrdinal() - 1);
    },

    _getCurrentlyExpandedNodeOrdinal: function() {
        return this._expandedNode.get('PortfolioItemType').Ordinal;
    },

    _updateStoreModelWithCurrentlyExpandedType: function(store) {
        this._updateStoreModel(store, this._getTaskModelForExpandedType());
    },

    _onBeforeStoreLoad:function (store, operation) {
        if(operation.node && operation.node.parentNode) {
            this._expandedNode = operation.node;
        }
        
        if(this._expandedNode) {
            this._updateStoreModelWithCurrentlyExpandedType(store);
        }

        operation.filters = this._getCurrentFilter();
        operation.fetch = this._getCurrentFetch();

        //Set context correctly for tree expand
        if (operation.node && operation.node.get('_ref')) {
            operation.context = operation.context || {};
            operation.context.project = null;

            if (this._expandedNode) {
                operation.context.workspace = '/workspace/' + Rally.util.Ref.getOidFromRef(this._expandedNode.get('Workspace')._ref);
            }
        }
    },

    //When the store is initialized with its model, the process of finding the root node decorates
    //the model with additional fields that the tree uses for display. As we move through the tree, the new model needs to be updated
    //with the additional fields (If you don't you get cherkberxes ermahgerd.)
    _updateStoreModel: function(store, model) {
        store.model = model;
        store.setProxy(model.proxy);
        store.getProxy().getReader().buildExtractors(true);
    },

    _onBeforeExpand:function (node) {
        this.fireEvent('beforeexpandnode', this);
    },

    _getTimelineConfig:function () {
        var taskStoreConfig = Ext.apply({
            model:this._getModelForCurrentType(),
            fetch:this._getCurrentFetch(),
            listeners:{
                beforeload:this._onBeforeStoreLoad,
                beforeexpand:this._onBeforeExpand,
                load: this._onTimelineLoaded,
                scope:this
            }
        }, this.taskStoreConfig);

        var projectName = '',
            scopeUp = '',
            scopeDown = '';

        if (this.context) {
            projectName = this.context.projectName;
            scopeUp = this.context.projectScopeUp;
            scopeDown = this.context.projectScopeDown;
        } else {
            var scope = Rally.getScope();
            if(scope.project) {
                projectName = scope.project.Name;
                scopeUp = scope.up;
                scopeDown = scope.down;
            }
        }

        return {
            plugins: new Gnt.plugin.Printable({
                mainTpl: Ext.create('Rally.alm.ui.timeline.PrintTimelineTemplate', {
                    projectName: projectName,
                    scopeUp: scopeUp,
                    scopeDown: scopeDown,
                    typeName: this.typeComboBox.rawValue
                })
            }),
            taskStoreConfig: taskStoreConfig,
            leftLabelField: '',
            baselineStartDateField: this.actualStartDateField,
            baselineEndDateField: this.actualEndDateField,
            startDateField : this.estimatedStartDateField,
            endDateField : this.estimatedEndDateField,
            childCountField: this.childCountField,
            columns: this._getColumnConfigs(),
            zoomLevel:this.getZoomLevel(),
            startDate: this.taskStoreConfig.startDate,
            endDate: this.taskStoreConfig.endDate,
            eventRenderer: function(taskRec){
                return {
                    cls: Rally.util.Test.toBrowserTestCssClass('estimated-bar', taskRec.get('ObjectID')),
                    basecls: Rally.util.Test.toBrowserTestCssClass('actual-bar', taskRec.get('ObjectID'))
                };
            },
            viewConfig: {
                loadMask: false
            },
            /**
             * View config for the Gantt Panel, and not the left tree panel
             */
            normalViewConfig: {
                emptyText: this._getEmptyText()
            },
            enableTaskDragDrop: false,
            enableDragCreation: false,
            enableDependencyDragDrop: false,
            resizeHandles: 'none',
            trackHeaderOver: false
        };
    },

    _getEmptyText: function() {
        var messageTpl = Ext.create('Ext.XTemplate', this.emptyTextTpl);
        var record = this._getTypeRecordFromComboBox();
        var message = messageTpl.apply({selectedType: record.get('Name')});
        var emptyTextMessage = Rally.ui.EmptyTextFactory.getEmptyTextFor(message);

        return emptyTextMessage;
    },

    _onTimelineLoaded: function(taskStore) {
        this.fireEvent('load', this, {});

        if (taskStore.getCount() === 0 && this.timeline.todayLinePlugin) {
            this.timeline.todayLinePlugin.setDisabled(true);
        }

        this._expandedNode = undefined;

        if (this.getFullScreen()) {
            this._resizeTimelineToFit();
        }

        if (Rally.BrowserTest) {
            Rally.BrowserTest.publishComponentReady(this);
        }
    },

    _getRecordFor:function(el, view){
        var row = el.up('tr');
        return view.getRecord(row);
    },

    _getTypeFilter:function () {
        var record = this._getTypeRecordFromComboBox();
        return {
            property:this.piTypeField,
            operator:'=',
            value:Rally.util.Ref.getRelativeUri(record.get('_ref'))
        };
    },

    _getColumnConfigs:function () {
        return [
            {
                xtype:'treecolumn',
                header:"Name",
                dataIndex:'Name',
                width: 200,
                menuDisabled:true,
                renderer:function (value, metaData,record) {
                    return Ext.create('Ext.XTemplate',
                            '<a href="{[this.createDetailUrl(values)]}" target="_top">{FormattedID}:</a> {Name}',
                            {
                                createDetailUrl:function (values) {
                                    return Rally.nav.Manager.getDetailUrl(values);
                                }
                            }).apply(record.data);
                }
            }
        ];
    },

    setWidth:function (w) {
        this.callParent(arguments);
        if (this.timeline) {
            this.timeline.setWidth(w);
        }
    },

    getSelectedZoomLevel:function () {
        return this.timeline.getZoomLevel();
    },

    getDefaultZoomLevel: function(){
        return 'monthAndYear';
    },

    getSelectedType:function () {
        return this.typeComboBox.getValue();
    },

    zoom:function(zoom){
        this.timeline.zoom(zoom);
    },

    getSliderValueFromZoom:function(zoom){
        var sliderValue = this.zoomLevels.indexOf(zoom.preset || zoom);
        //if not found return a reasonable default
        return Math.max(sliderValue,0);
    }
});
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Ext.Component',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
     title: "Build Information",
    
    renderTpl: "<div id='{id}-infolinkWrap' class='tsinfolink'>--</div>",

    initComponent: function() {
        this.callParent(arguments);
       
    },
    
    onRender: function() {
        this.callParent(arguments);
        this.mon(this.el,'click',this.onClick,this);
    },
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
    
        return chk;
    },
    _checkChecksum: function(container) {
        var me = this;
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    if ( CHECKSUM !== me._generateChecksum(text) ) {
                        console.log("Checksums don't match!");
                        if ( me.dialog ) {
                            me.dialog.add({xtype:'container',html:'Checksums do not match'});
                        }
                    }
                }
            }
        });
    },
    onClick: function(e) {
        var me = this;
        this._checkChecksum(this);
        
        var dialog_items = [];
        
        if ( this.informationHtml ) {
            dialog_items.push({
                xtype:'container',
                html: this.informationHtml
            });
        }
                
        dialog_items.push({
            xtype:'container',
            html:"This app was created by the Rally Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            dialog_items.push({
                xtype:'container',
                html:'Build date/time: ' + APP_BUILD_DATE
            });
        }
        
        if (this.dialog){this.dialog.destroy();}
        this.dialog = Ext.create('Rally.ui.dialog.Dialog',{
            defaults: { padding: 5, margin: 5 },
            closable: true,
            draggable: true,
            title: me.title,
            items: dialog_items
        });
        this.dialog.show();
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

Ext.define('CustomApp', {
    extend: 'Rally.app.App',
    componentCls: 'app',
    logger: new Rally.technicalservices.Logger(),
    items: [
        {xtype:'container',itemId:'message_box',tpl:'Hello, <tpl>{_refObjectName}</tpl>'},
        {xtype:'container',itemId:'display_box'} 
        /*,
        {xtype:'tsinfolink'}
        */
    ],
    launch: function() {
        // this.down('#message_box').update(this.getContext().getUser());
        var me = this;

        me.down('#display_box').add({
            xtype: 'almportfolioitemtimeline',
            context: me.getContext()
        });
    }
});

            
               Rally.launchApp('CustomApp', {
                   name: 'Timeline With Dependencies'
               });
        });
    </script>
    
    <link rel="stylesheet" type="text/css" href="/slm/pack/combined.css.h-316466415.pack">
    <!--
    <link rel="stylesheet" type="text/css" href="/slm/pack/combined.css.h-458667689.pack">
    <link rel="stylesheet" type="text/css" href="/slm/pack/combined.css.h-540919694.pack">
    <link rel="stylesheet" type="text/css" href="/slm/pack/combined.css.h482711781.pack">
    -->
    <link rel="stylesheet" type="text/css" href="/slm/js-lib/rui/builds/rui/resources/css/rui-fonts.css">

    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width:5%;
}

.x-unselectable {
    user-select: none;
    -o-user-select: none;
    -ms-user-select: none;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
    cursor: default;
}

.x-grid-cell-inner {
    white-space: nowrap;
    zoom: 1;
}

.x-tree-elbow-img, .x-tree-icon {
    background-repeat: no-repeat;
    background-position: 0 center;
    vertical-align: top;
}

.sch-ganttpanel .x-tree-panel .x-tree-icon-parent, .sch-ganttpanel .x-tree-panel .x-tree-icon-leaf {
    background: none;
    width: 0;
}

td.sch-timetd .x-grid-cell-inner {
    position: relative;
    padding-left: 0;
    padding-right: 0;
    cursor: default;
    overflow: visible;
}


    </style>

</head>
<body></body>
</html>