<!DOCTYPE html>
<html>
<head>
    <title>Timeline With Dependencies</title>
    <!--  (c) 2014 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Wed Feb 26 2014 20:06:29 GMT-0800 (PST) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Wed Feb 26 2014 20:06:29 GMT-0800 (PST)";
        var CHECKSUM = 178039391616;
    </script>
    
    <script type="text/javascript" src="/apps/x/sdk.js"></script>
    <script type="text/javascript" src="/slm/js-lib/ext-gantt/2.2.15/gnt-all.js"></script>
    <script type="text/javascript" src="/slm/js/alm/src/ui/timeline/TaskModelFactory.js"></script>

    <!-- 
    <script type="text/javascript" src="/slm/js/alm/src/ui/timeline/Timeline.js"></script>
    -->
    <script type="text/javascript" src="/slm/js/alm/src/ui/timeline/PrintTimelineTemplate.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
/**
 * Overrides Gnt.template.Task in gnt-fix.js to replace the 'actual' line renderer with a custom percent done renderer.
 */
Ext.define("Rally.alm.ui.timeline.PercentDoneTaskTemplate", {
    extend : 'Ext.XTemplate',
    requires: [
        'Rally.util.HealthColorCalculator'
    ],

    constructor: function(cfg) {

        cfg.leftLabel = 'test';

        this.callParent([
                '<div class="sch-event-wrap {ctcls} x-unselectable" style="left:{offset}px;">' +
                // Left label
                    '<div class="sch-gantt-labelct sch-gantt-labelct-left"><label class="sch-gantt-label sch-gantt-label-left">{[this.getPercentDoneValue(values)]}%</label></div>' +

                // Task bar
                    '<div id="' + cfg.prefix + '{id}" class="sch-gantt-item sch-gantt-task-bar {internalcls} {cls}" unselectable="on" style="background-color:{[this.getPercentDoneColor(values)]} !important;width:{width}px;{style}">'+
                // Left terminal
                    (cfg.enableDependencyDragDrop ? '<div unselectable="on" class="sch-gantt-terminal sch-gantt-terminal-start"></div>' : '') +
                    ((cfg.resizeHandles === 'both' || cfg.resizeHandles === 'left') ? '<div class="sch-resizable-handle sch-gantt-task-handle sch-resizable-handle-west"></div>' : '') +

                    '<div class="sch-gantt-progress-bar" style="width:{percentDone}%;{progressBarStyle}" unselectable="on">&#160;</div>' +

                    ((cfg.resizeHandles === 'both' || cfg.resizeHandles === 'right') ? '<div class="sch-resizable-handle sch-gantt-task-handle sch-resizable-handle-east"></div>' : '') +
                // Right terminal
                    (cfg.enableDependencyDragDrop ? '<div unselectable="on" class="sch-gantt-terminal sch-gantt-terminal-end"></div>' : '') +
                    (cfg.enableProgressBarResize ? '<div style="left:{percentDone}%" class="sch-gantt-progressbar-handle"></div>': '') +
                    '</div>' +

                // Right label
                    (cfg.rightLabel ? '<div class="sch-gantt-labelct sch-gantt-labelct-right" style="left:{width}px"><label class="sch-gantt-label sch-gantt-label-right">{rightLabel}</label></div>' : '') +
                '</div>',
            {
                compiled: true,
                disableFormats: true,
                getPercentDoneValue: function(options) {
                    var record = options.taskModel;
                    return Math.round(record.get('PercentDoneByStoryCount') * 100);
                },
                getPercentDoneColor: function(options){
                    var record = options.taskModel;
                    var colorObject = Rally.util.HealthColorCalculator.calculateHealthColorForPortfolioItemData(record.data, 'PercentDoneByStoryCount');
                    return colorObject.hex;
                }
            }
        ]);
    }

});

/**
 * Overrides Gnt.template.ParentTask in gnt-fix.js to replace the 'actual' line renderer with a custom percent done renderer.
 */
Ext.define("Rally.alm.ui.timeline.PercentDoneParentTaskTemplate", {
    extend : 'Ext.XTemplate',
    requires: [
        'Rally.util.HealthColorCalculator'
    ],

    constructor: function(cfg) {

        this.callParent([
                '<div class="sch-event-wrap {ctcls} x-unselectable" style="left:{offset}px;width:{width}px">'+
                // Left label
                    '<div class="sch-gantt-labelct sch-gantt-labelct-left"><label class="sch-gantt-label sch-gantt-label-left">{[this.getPercentDoneValue(values)]}%</label></div>'+

                // Task bar
                    '<div id="' + cfg.prefix + '{id}" class="sch-gantt-item sch-gantt-parenttask-bar {internalcls} {cls}" style="background-color:{[this.getPercentDoneColor(values)]} !important;{style}">'+
                // Left terminal

                    '<div class="sch-gantt-progress-bar" style="width:{percentDone}%;{progressBarStyle}">&#160;</div>'+
                    (cfg.enableDependencyDragDrop ? '<div class="sch-gantt-terminal sch-gantt-terminal-start"></div>' : '') +

                    '<div class="sch-gantt-parenttask-arrow sch-gantt-parenttask-leftarrow"></div>'+
                    '<div class="sch-gantt-parenttask-arrow sch-gantt-parenttask-rightarrow"></div>'+
                // Right terminal
                    (cfg.enableDependencyDragDrop ? '<div class="sch-gantt-terminal sch-gantt-terminal-end"></div>' : '') +
                    '</div>'+

                // Right label
                    (cfg.rightLabel ? '<div class="sch-gantt-labelct sch-gantt-labelct-right" style="left:{width}px"><label class="sch-gantt-label sch-gantt-label-right">{rightLabel}</label></div>' : '') +
                '</div>',
            {
                compiled: true,
                disableFormats: true,
                getPercentDoneValue: function(options) {
                    var record = options.taskModel;
                    return Math.round(record.get('PercentDoneByStoryCount') * 100);
                },
                getPercentDoneColor: function(options){
                    var record = options.taskModel;
                    var colorObject = Rally.util.HealthColorCalculator.calculateHealthColorForPortfolioItemData(record.data, 'PercentDoneByStoryCount');
                    return colorObject.hex;
                }
            }
        ]);
    }

});


//workaround for treestore used by timeline component not passing store params to proxy correctly
//(context, fetch, filters) and bug with deleting data on store load
Ext.override(Ext.data.TreeStore, {
    load: function(options) {
        options = options || {};
        options.params = options.params || {};

        var me = this,
            node = options.node || me.tree.getRootNode(),
            callback = options.callback,
            scope = options.scope,
            operation;

        //pass along additional params
        options.fetch = options.fetch || this.fetch;
        options.context = options.context || this.context;

        // If there is not a node it means the user hasnt defined a rootnode yet. In this case let's just
        // create one for them.
        if (!node) {
            node = me.setRootNode({
                expanded: true
            }, true);
        }

        // If the node we are loading was expanded, we have to expand it after the load
        if (node.data.expanded) {
            node.data.loaded = false;

            // Must set expanded to false otherwise the onProxyLoad->fillNode->appendChild calls will update the view.
            // We ned to update the view in the callback below.
            if (me.clearOnLoad) {
                node.data.expanded = false;
            }
            options.callback = function() {

                // If newly loaded nodes are to be added to the existing child node set, then we have to collapse
                // first so that they get removed from the NodeStore, and the subsequent expand will reveal the
                // newly augmented child node set.
                if (!me.clearOnLoad) {
                    node.collapse();
                }
                node.expand();

                // Call the original callback (if any)
                Ext.callback(callback, scope, arguments);
            };
        }

        // Assign the ID of the Operation so that a ServerProxy can set its idParam parameter,
        // or a REST proxy can create the correct URL
        options.id = node.getId();

        options = Ext.apply({
            action: 'read',
            filters: me.filters.items,
            sorters: me.getSorters(),
            node: options.node || node
        }, options);

        me.lastOptions = options;

        operation = new Ext.data.Operation(options);

        if (me.fireEvent('beforeload', me, operation) !== false) {
            if (me.clearOnLoad) {
                if(me.clearRemovedOnLoad) {
                    // clear from the removed array any nodes that were descendants of the node being reloaded so that they do not get saved on next sync.
                    me.clearRemoved(node);
                }
                // temporarily remove the onNodeRemove event listener so that when removeAll is called, the removed nodes do not get added to the removed array
                me.tree.un('remove', me.onNodeRemove, me);
                // remove all the nodes
                node.removeAll(false);
                // reattach the onNodeRemove listener
                me.tree.on('remove', me.onNodeRemove, me);
            }
            me.loading = true;
            me.proxy.read(operation, me.onProxyLoad, me);
        }

        if (me.loading && node) {
            node.set('loading', true);
        }

        return me;
    }
});

//workaround for Gantt behavior that causes tooltip end date to be one day too early
Ext.override(Gnt.view.Gantt, {
    getFormattedEndDate: function(endDate, startDate) {
        return Ext.Date.format(endDate, this.getDisplayDateFormat());
    }
});

Ext.override(Gnt.view.Gantt, {
/**
 * Overridden to use a custom template for the actual bar (baseline task and baseline parent task templates, in gantt language).
 * Look for FIX: for spots that you need to pay attention to
 */
    setupTemplates: function(){
        this.callParent(arguments);
    
        var tplCfg = {
            prefix : this.eventPrefix
        };
    
        // FIX: create baseline templates for actual values (2.1.15 reuses eventTemplate...)
        this.baselineTaskTemplate = Ext.create("Rally.alm.ui.timeline.PercentDoneTaskTemplate", tplCfg);
        this.baselineParentTaskTemplate = Ext.create("Rally.alm.ui.timeline.PercentDoneParentTaskTemplate", tplCfg);
    },
     /**
     * Overridden to pass in the taskModel into the baseTpl call, so we can have access to the actual PI record
     * when we're rendering the actual bar (Rally.alm.ui.timeline.PercentDoneTaskTemplate).
     */

    columnRenderer: function (value, meta, taskModel) {
        var taskStart = taskModel.getStartDate(),
            ta = this.timeAxis,
            D = Sch.util.Date,
            tplData = {},
            cellResult = '',
            ctcls = '',
            viewStart = ta.getStart(),
            viewEnd = ta.getEnd(),
            isMilestone = taskModel.isMilestone(),
            isLeaf = taskModel.isLeaf(),
            userData, startsInsideView, endsOutsideView;

        if (taskStart) {
            var taskEnd = taskModel.getEndDate() || Sch.util.Date.add(taskStart, Sch.util.Date.DAY, 1),
                doRender = Sch.util.Date.intersectSpans(taskStart, taskEnd, viewStart, viewEnd);

            if (doRender) {
                endsOutsideView = taskEnd > viewEnd;
                startsInsideView = D.betweenLesser(taskStart, viewStart, viewEnd);

                var taskStartX = Math.floor(this.getXFromDate(startsInsideView ? taskStart : viewStart)),
                    taskEndX = Math.floor(this.getXFromDate(endsOutsideView ? viewEnd : taskEnd)),
                    itemWidth = isMilestone ? 0 : taskEndX - taskStartX,
                    lField = this.leftLabelField,
                    rField = this.rightLabelField,
                    tField = this.topLabelField,
                    bField = this.bottomLabelField,
                    tpl = this.getTemplateForTask(taskModel);

                if (!isMilestone && !isLeaf) {
                    if (endsOutsideView) {
                        itemWidth += this.parentTaskOffset; // Compensate for the parent arrow offset (6px on left side)
                    } else {
                        itemWidth += 2 * this.parentTaskOffset; // Compensate for the parent arrow offset (6px on both sides)
                    }
                }

                tplData = {
                    // Core properties
                    id          : taskModel.internalId,
                    offset      : isMilestone ? (taskEndX || taskStartX) - this.getXOffset(taskModel) : taskStartX,
                    width       : Math.max(1, itemWidth),
                    ctcls       : '',
                    cls         : '',
                    print       : this._print,
                    record      : taskModel,
                    // Percent complete
                    percentDone : Math.min(taskModel.getPercentDone() || 0, 100)
                };

                // Get data from user "renderer"
                userData = this.eventRenderer.call(this.eventRendererScope || this, taskModel, tplData, taskModel.store) || {};

                if (lField) {
                    // Labels
                    tplData.leftLabel = lField.renderer.call(lField.scope || this, taskModel.data[lField.dataIndex], taskModel);
                }

                if (rField) {
                    tplData.rightLabel = rField.renderer.call(rField.scope || this, taskModel.data[rField.dataIndex], taskModel);
                }

                if (tField) {
                    tplData.topLabel = tField.renderer.call(tField.scope || this, taskModel.data[tField.dataIndex], taskModel);
                }

                if (bField) {
                    tplData.bottomLabel = bField.renderer.call(bField.scope || this, taskModel.data[bField.dataIndex], taskModel);
                }

                Ext.apply(tplData, userData);

                var dataCls = ' sch-event-resizable-' + taskModel.getResizable();

                if (isMilestone) {
                    tplData.side = Math.round((this.enableBaseline ? 0.4 : 0.5) * this.rowHeight);
                    ctcls += " sch-gantt-milestone";
                } else {
                    tplData.width = Math.max(1, itemWidth);

                    if (endsOutsideView) {
                        ctcls += ' sch-event-endsoutside ';
                    }

                    if (!startsInsideView) {
                        ctcls += ' sch-event-startsoutside ';
                    }

                    if (isLeaf) {
                        ctcls += " sch-gantt-task";
                    } else {
                        ctcls += " sch-gantt-parent-task";
                    }
                }

                if (taskModel.dirty) {
                    dataCls += ' sch-dirty ';
                }

                if (taskModel.isDraggable() === false) {
                    dataCls += ' sch-event-fixed ';
                }

                tplData.cls = (tplData.cls || '') + (taskModel.getCls() || '') + dataCls;
                tplData.ctcls += ' ' + ctcls;

                cellResult += tpl.apply(tplData);
            }
        }

        if (this.enableBaseline) {

            var taskBaselineStart           = taskModel.getBaselineStartDate(),
                taskBaselineEnd             = taskModel.getBaselineEndDate();

            if (!userData) {
                userData                    = this.eventRenderer.call(this, taskModel, tplData, taskModel.store) || {};
            }

            if (taskBaselineStart && taskBaselineEnd && Sch.util.Date.intersectSpans(taskBaselineStart, taskBaselineEnd, viewStart, viewEnd)) {
                endsOutsideView             = taskBaselineEnd > viewEnd;
                startsInsideView            = D.betweenLesser(taskBaselineStart, viewStart, viewEnd);

                var isBaselineMilestone     = taskModel.isBaselineMilestone(),
                    baseStartX              = Math.floor(this.getXFromDate(startsInsideView ? taskBaselineStart : viewStart)),
                    baseEndX                = Math.floor(this.getXFromDate(endsOutsideView ? viewEnd : taskBaselineEnd)),
                    baseWidth               = isBaselineMilestone ? 0 : baseEndX - baseStartX,
                    baseTpl                 = this.getTemplateForTask(taskModel, true),
                    data                    = {
                        progressBarStyle : userData.baseProgressBarStyle || '',
                        id               : taskModel.internalId + '-base',
                        percentDone      : taskModel.getBaselinePercentDone(),
                        offset           : isBaselineMilestone ? (baseEndX || baseStartX) - this.getXOffset(taskModel, true) : baseStartX,
                        print            : this._print,
                        width            : Math.max(1, baseWidth),
                        baseline         : true,
                        taskModel        : taskModel // FIX pass the taskModel in
                    };

                // FIX use our templates instead of event templates
                if(taskModel.isLeaf()) {
                    baseTpl = this.baselineTaskTemplate;
                } else if (!isBaselineMilestone) {
                    baseTpl = this.baselineParentTaskTemplate;
                }

                ctcls                       = '';

                if (isBaselineMilestone) {
                    data.side               = Math.round(0.40 * this.rowHeight);
                    ctcls                   = "sch-gantt-milestone-baseline sch-gantt-baseline-item";
                } else if (taskModel.isLeaf()) {
                    ctcls                   = "sch-gantt-task-baseline sch-gantt-baseline-item";
                } else {
                    ctcls                   = "sch-gantt-parenttask-baseline sch-gantt-baseline-item";
                }

                if (endsOutsideView) {
                    ctcls                   += ' sch-event-endsoutside ';
                }

                if (!startsInsideView) {
                    ctcls                   += ' sch-event-startsoutside ';
                }

                // HACK, a bit inconsistent. 'basecls' should probably end up on the task el instead of the wrapper.
                data.ctcls                  = ctcls + ' ' + (userData.basecls || '');

                cellResult                  += baseTpl.apply(data);
            }
        }

        return cellResult;
    }
});
/**
 * The timeline component.
 */
Ext.define('Rally.alm.ui.timeline.Timeline', {
    alias:"widget.almtimeline",
    extend: 'Gnt.panel.Gantt',
    
    requires: [
        'Sch.util.Date',
        'Sch.preset.Manager',
        'Rally.ui.renderer.RendererFactory',
        'Rally.alm.ui.timeline.TaskModelFactory',
        'Gnt.plugin.Printable'
    ],

    bubbleEvents:['add','remove','zoom','taskclick'],

    statics:{
        errorMessages:{
            missingTreeColumn:  "Timeline component requires that at least one column in the config is of xtype treecolumn",
            columnMustBeAnArray:  "Timeline component requires columns to be sent into the config as an array"
        }
    },

    clientMetrics: {
        beginEvent: 'added',
        endEvent: 'load',
        description: 'timeline loaded'
    },

    itemId: 'rallyTimeline',
    height: 350,
    width: '100%',
    highlightWeekends: false,
    loadMask: true,
    config: {
        /**
         * @cfg {String} viewPreset A key used to lookup a predefined Sch.preset.ViewPreset (e.g. 'weekAndDay', 'hourAndDay'), managed by Sch.preset.Manager. See Sch.preset.Manager for more information.
         * Do not use this, use zoomLevel instead.
         */

        /**
         * @cfg {String} leftLabelField The field that will be displayed to the left of each bar can be deleted to have the component show no fields.
         * This field will be used to find the renderer off of the model if possible to render the field properly.
         */
        leftLabelField:"_refObjectName",

        /**
         * @cfg {String} rightLabelField The field that will be displayed to the right of each bar. Can be deleted to have the component show nothing.
         * This field will be used to find the renderer off of the model if possible to render the field properly.
         */

        /**
         * @cfg {String}
         * The date field that will be used for the left border of the item's time representation.
         */
        startDate: Sch.util.Date.add(new Date(), Sch.util.Date.MONTH, -3),

        /**
         * @cfg {String}
         * The date field that will be used for the right border of the item's time representation.
         */
        endDate: Sch.util.Date.add(new Date(), Sch.util.Date.YEAR, 1),

        /**
         * @cfg {Boolean} showTodayLine
         * Controls whether or not a vertical line is shown at today's date
         */
        showTodayLine: true,

        /**
         * @cfg {String} startDateField
         * The date field to determine the start of the task bar
         */

        /**
         * @cfg {String} endDateField
         * The date field to determine the end of the task bar
         */

        /**
         * @cfg {Number} baselinePercentDoneField
         * The date field to determine the percent done for the task bar
         */

        /**
         * @cfg {String} baselineStartDateField
         * The date field to determine the start of the baseline bar
         */

        /**
         * @cfg {String} baselineEndDateField
         * The date field to determine the end of the baseline bar
         */

        /**
         * @cfg {Number} percentDoneField
         * The field that will be used for the percent done portion of the item's time representation.
         */

        /**
         * @cfg {Boolean} toggleParentTasksOnClick
         * Whether or not clicking on timeline bars causes a hierarchcy expand/collapse
         */
        toggleParentTasksOnClick: false,

        /**
         * @cfg {String} childCountField
         * The field from which to determine whether an item has children
         */
        childCountField: 'Children',

        /**
         * @cfg {Number/String}
         * The default zoom level.  Either a string or an index into the Rally.alm.ui.timeline.Timeline#zoomLevels array.
         */
        zoomLevel: 'rallyWeekAndMonth',

        /**
         * @cfg {Object[]}
         * The zoom levels that are supported by Rally.alm.ui.timeline.Timeline#zoom.
         * See Sch.preset.Manager for valid values.
         */
        zoomLevels: [
            { width: 30,    increment: 1,   resolution: 1, preset: 'year', resolutionUnit: 'MONTH' },
            { width: 100,   increment: 1,   resolution: 7, preset: 'monthAndYear', resolutionUnit: 'DAY'},
            { width: 50,    increment: 1,   resolution: 1, preset: 'rallyWeekAndMonth', resolutionUnit: 'DAY'}
        ]
    },

    plugins: new Gnt.plugin.Printable(),

    constructor: function(config) {
        this.initConfig(config);

        //adjust end date for using ie to add an additional week for layout
        this._adjustEndDateForIERendering();

        this._createRallyDefaultViewPreset();

        if (!config.columns) {
            config.columns = this.getDefaultColumns(config.taskStoreConfig.model);
        }

        this.zoomLevel = this._resolveZoomLevel(this.zoomLevel);

        config.viewPreset = this.zoomLevel.preset;

        var taskStoreConfig = Ext.apply({
            autoLoad: true,
            sorters: [
                {
                    property: 'Name',
                    direction: 'DESC'
                }
            ],
            listeners: {
                load: this._onLoaded,
                scope: this
            },
            recalculateParents: false
        }, config.taskStoreConfig);
        
        taskStoreConfig.model = Rally.alm.ui.timeline.TaskModelFactory.getTaskModel({
            wsapiModel: taskStoreConfig.model
        });
        
        var taskStore = Ext.create("Gnt.data.TaskStore", taskStoreConfig);
        taskStore.on('load', this._onLoaded, this);

        config.taskStore = taskStore;

        this._validateColumns(config.columns);

        if (config.leftLabelField) {
            config.leftLabelField = this._generateLabelFieldConfig(this.config.leftLabelField, config.taskStore.model);
        }
        if (config.rightLabelField) {
            config.rightLabelField = this._generateLabelFieldConfig(this.config.rightLabelField, config.taskStore.model);
        }

        if (config.baselineStartDateField && config.baselineEndDateField) {
            config.enableBaseline =  true;
            config.baselineVisible = true;
        }

        this.callParent(arguments);
    },

    _resolveZoomLevel: function(zoomLevel) {
        var resolvedZoomLevel;

        if(_.isObject(zoomLevel)) {
            resolvedZoomLevel = zoomLevel;
        }

        if(_.isNumber(zoomLevel)) {
            resolvedZoomLevel = this.zoomLevels[zoomLevel];
        }

        if(_.isString(zoomLevel)) {
            resolvedZoomLevel = _.find(this.zoomLevels, { preset: zoomLevel });

        }

        return resolvedZoomLevel || this.zoomLevels[2];
    },

    _adjustEndDateForIERendering: function() {
        //IE hack to handle crap display when 1st of the month is on or after Thursday not past the first Sunday of the month
        var endDateCalendarDay = this.endDate.getDate();
        var endDateDayOfWeek = this.endDate.getDay();
        if (endDateCalendarDay <= 4 && (endDateDayOfWeek < 2 || endDateDayOfWeek > 4)) {
            var addWeek = false;
            switch (endDateDayOfWeek) {
                case 5: //Friday
                    addWeek = (endDateCalendarDay < 2);
                    break;
                case 6: //Saturday
                    addWeek = (endDateCalendarDay < 3);
                    break;
                case 0: //Sunday
                    addWeek = (endDateCalendarDay < 4);
                    break;
                case 1: //Monday
                    addWeek = (endDateCalendarDay !== 1);
                    break;
            }
            if (addWeek) {
                this.endDate = Sch.util.Date.add(this.endDate, Sch.util.Date.DAY, 7);
            }
        }
    },

    initComponent: function() {
        this.callParent(arguments);

        this.addEvents([
           /**
            * @event
            * Fires when a zoom has completed
            * @param {Rally.alm.ui.timeline.Timeline} this
            * @param {Number} zoomLevel The new zoom level
            */
            'zoom',
            /**
             * @event
             * Fires after the timeline has loaded
             * @param {Rally.alm.ui.timeline.Timeline} this
             */
            'afterload'
        ]);
    },

    /**
     * Set the Timeline's zoom level
     * @param {Number/String} zoomLevel A number between 0 and length of Rally.alm.ui.timeline.Timeline#zoomLevels - 1.
     * This number will be used to index the Rally.alm.ui.timeline.Timeline#zoomLevels array.
     * Alternatively, you can pass in a string element in the Rally.alm.ui.timeline.Timeline#zoomLevels array.
     */
    zoom: function(zoomLevel){
        zoomLevel = this._resolveZoomLevel(zoomLevel);
        this.switchViewPreset(zoomLevel.preset, this.startDate, this.endDate);
        if(this.getStore().getCount() > 0){
            this._scrollNearToday();
        }
        this.zoomLevel = zoomLevel;
        this.fireEvent('zoom', zoomLevel);
    },

    _onLoaded: function(taskStore, model, records) {
        if (this.isVisible()) {
            this._ieFixHeaderWidthComputeIssue();

            this.suspendEvents();
            this.zoom(this.zoomLevel);
            this.resumeEvents();

            if(records.length < 1){
                //empty message is to the left, scroll there if we don't have any records
                this.getSchedulingView().getEl().scrollTo('left', 0);
            }

            //slim down the space between the tree and the timeline
            this.down('bordersplitter').setWidth(2);

            if(records.length >= 1) {
                this._scrollNearToday();
            }

            this.fireEvent('afterload');
        }
    },

    _scrollNearToday: function(){
        this.scrollToDate(Rally.util.DateTime.add(new Date(), 'day', -14));
    },

    _getViewportLeftDate: function() {
         var schedulingView = this.getSchedulingView();
         var scroll = schedulingView.getEl().getScroll();

         var xCoordinate = [scroll.left, 0];
         return schedulingView.getDateFromXY(xCoordinate, null, true);
     },

    show: function() {
        this._ieFixHeaderWidthComputeIssue();
        this.callParent(arguments);
    },

    _ieFixHeaderWidthComputeIssue: function() {
        if (Ext.isIE) {
            var svTimeaxisHdr = this.getEl().down('.sch-timeaxiscolumn');
            if (svTimeaxisHdr) {
                var svHdr = svTimeaxisHdr.up('div');
                if (svHdr) {
                    var svHdrWidth = svHdr.dom.style.width;
                    if (svHdrWidth) {
                        if (svTimeaxisHdr.dom.style.width && svTimeaxisHdr.dom.style.width !== svHdrWidth) {
                            svTimeaxisHdr.dom.style.width = svHdrWidth;
                        }
                        var hdrTable = svHdr.down('table');
                        if (hdrTable.dom.style.width && hdrTable.dom.style.width !== svHdrWidth) {
                            hdrTable.dom.style.width = svHdrWidth;
                        }
                    }
                }
            }
        }
    },

    // Setup your static columns
    /**
     * @return {Object} Returns the set of default columns for a timeline
     */
    getDefaultColumns: function(model) {
        var nameField = model.getField("Name");
        if (nameField) {
            return [
                {
                    xtype : 'treecolumn',
                    header:"Name",
                    dataIndex: 'Name',
                    width: 200,
                    menuDisabled: true
                }
            ];
        }
        else {
            return [
                {
                    xtype : 'treecolumn',
                    header:"Name",
                    dataIndex: '_refObjectName',
                    width: 200
                }
            ];
        }
    },

    //checks to make sure that a tree column is specified.
    _validateColumns:function(columns) {
        if (!Ext.isArray(columns)) {
            throw this.self.errorMessages.columnMustBeAnArray;
        }
        var types = Ext.Array.pluck(columns, "xtype");
        if (Ext.Array.indexOf(types, "treecolumn") == -1) {
            throw this.self.errorMessages.missingTreeColumn;
        }
    },

    _generateLabelFieldConfig:function(labelField, model) {
        if (Ext.isString(labelField)) {
            return {
                dataIndex:labelField,
                renderer:function(value, record) {
                    var template = Rally.ui.renderer.RendererFactory.getRenderTemplate(model.getField(labelField));
                    return template.apply(record.data);
                }
            };
        }
        return labelField;
    },

    _createRallyDefaultViewPreset: function() {
        var curContext = Rally.environment.getContext();
        var userDateFormat = curContext.getUser().UserProfile.DateFormat ||
                curContext.getWorkspace().WorkspaceConfiguration.DateFormat;

        var config = {
            timeColumnWidth : 100,
            rowHeight: 24,          // Only used in horizontal orientation
            resourceColumnWidth : 100,  // Only used in vertical orientation
            displayDateFormat : 'Y-m-d',
            shiftUnit : "WEEK",
            shiftIncrement : 5,
            defaultSpan : 6,       // By default, show 6 weeks
            timeResolution : {
                unit : "DAY",
                increment : 1
            },
            headerConfig : {
                middle : {
                    unit : "WEEK",
                    renderer : function(start, end, cfg) {
                        return Rally.util.DateTime.format(start, userDateFormat);
                    }
                },
                top : {
                    unit : "MONTH",
                    dateFormat : 'M Y'
                }
            }
        };
        Sch.preset.Manager.registerPreset('rallyWeekAndMonth', config);
    }
});
Ext.define('DependencyTimeline',{
    extend: 'Rally.alm.ui.timeline.Timeline',
    alias:"widget.tsdependencytimeline",
    constructor: function(config) {
        this.initConfig(config);
 

        var dependencyStore = Ext.create("Gnt.data.DependencyStore", {
            autoLoad    : true,
            proxy       : {
                type    : 'memory',
                reader  : {
                    type: 'json'
                },
                data: [ ]
            }
        });
        
        this.dependencyStore = config.dependencyStore = dependencyStore;
        
        this.callParent(arguments);
    },
    _onLoaded: function(taskStore, model, records) {
        var me = this;
        Ext.Array.each(records, function(record) { record.set('Id',record.get('ObjectID')) ; } );
        
        var promises = [];
        Ext.Array.each(records, function(record) {
            var object_id = record.get('ObjectID');
            record.set('Id',object_id);
            promises.push(me._getDependencies(object_id));
        });

        Deft.Promise.all(promises).then({
            scope: this,
            success: function(records) {
                var dependencies = Ext.Array.flatten(records);
                this.dependencyStore.loadRawData(dependencies);
            },
            failure: function(error) {
                alert(error);
            }
        });
        this.callParent(arguments);
    },
    _getDependencies: function(object_id){
        var deferred = Ext.create('Deft.Deferred');
        Ext.create('Rally.data.wsapi.Store',{
            autoLoad: true,
            model:'UserStory',
            filters: [{property:'Feature.ObjectID',value:object_id}],
            fetch: ['ObjectID','Predecessors','Feature'],
            listeners: {
                scope: this,
                load: function(store,stories) {
                    var me = this; 
                    var promises = [];
                    Ext.Array.each(stories, function(story) {
                        if ( story.get('Predecessors').Count != 0 ) {
                            promises.push(me._getCollectionFromRecord(story,'Predecessors'));
                        }
                    });
                    if ( promises.length > 0 ) {
                        Deft.Promise.all(promises).then({
                            scope: this,
                            success: function(records) {
                                deferred.resolve(records);
                            },
                            failure: function(error) {
                                deferred.reject(error);
                            }
                        });
                    } else {
                        deferred.resolve([]);
                    }
                }
            }
        });
        return deferred.promise;
    },
    _getCollectionFromRecord: function(story,field_name) {
        var deferred = Ext.create('Deft.Deferred');
        story.getCollection(field_name).load({
            fetch: ['Feature','ObjectID'],
            callback: function(predecessors,operation,success){
                var dependencies = [];
                Ext.Array.each(predecessors,function(predecessor){
                    if ( predecessor.get('Feature') ) {
                        dependencies.push({
                            "From":predecessor.get('Feature').ObjectID,
                            "To"  :story.get('Feature').ObjectID,
                            "Type":3
                        });
                    }
                });
                deferred.resolve(dependencies);
            }
        });        
        return deferred.promise;
    }
});
/**
 * The portfolio item timeline component with type filter.
 */
Ext.define('Rally.alm.ui.timeline.PortfolioItemTimeline', {
    extend:'Ext.container.Container',
    requires:[
        'Rally.util.DateTime',
        'Rally.util.Test',
        'Rally.ui.ButtonSlider',
        'Rally.util.HealthColorCalculator',
        'Rally.ui.EmptyTextFactory',
        'Rally.alm.ui.timeline.Timeline',
        'DependencyTimeline'
    ],
    alias: 'widget.almportfolioitemtimeline',

    clientMetrics: [
        {
            event: 'beforeexpandnode',
            description: 'PI timeline node expanded'
        }
    ],

    config:{
        estimatedStartDateField:"PlannedStartDate",
        estimatedEndDateField:"PlannedEndDate",
        actualStartDateField:"ActualStartDate",
        actualEndDateField:"ActualEndDate",
        childCountField:'DirectChildrenCount',
        piTypeField:'PortfolioItemType',
        piTypeOrdinalValueField:'Ordinal',

        /**
         * @cfg {Boolean} fullScreen tell the component to monitor window resize events and resize to fill all available space
         */
        fullScreen:false,
        /**
         * @cfg {String} type The current PortfolioItem Type that will be shown
         */
        /**
         * @cfg {String} The current zoom level that will be shown.
         */
        zoomLevel:'monthAndYear',
        /**
         * @cfg {String}
         * the type to default the type dropdown to
         */
        type: undefined,

        /**
         * @cfg {String}
         * the optional query - allows a custom query to be added to filters sent to the WSAPI proxy
         */
        customQueryString: ''
    },

    zoomLevels: ['year', 'monthAndYear', 'rallyWeekAndMonth'],

    emptyTextTpl: ['<p>There are no {selectedType}(s) with current dates. <a href="#/portfolioitems">Manage Portfolio Items</a></p>',
        '<p>Rally Portfolio Manager allows you to plan and track longer-term initiatives, ',
        'with actual progress information rolling up from development teams. ',
        '{[Rally.alm.util.Help.getLinkTag({id: "224", text: "Learn more"})]} ',
        'about configuring Rally Portfolio Manager and best practices for creating Portfolio Items.</p>'],

    constructor: function(config) {

        this.config.taskStoreConfig = {
            startDate: Rally.util.DateTime.add(new Date(), Ext.Date.YEAR, -1),
            endDate: Rally.util.DateTime.add(new Date(), Ext.Date.YEAR, 1),
            skipWeekendsDuringDragDrop:false,
            weekendsAreWorkdays:true,
            sorters:[
                {
                    property:'Rank',
                    direction:'ASC'
                }
            ]
        };

        var conf = Ext.merge({}, this.config, config);

        this.initConfig(conf);
        this.callParent([conf]);
    },

    initComponent:function () {
        this.callParent(arguments);
        this.addEvents(
            /**
             * @event
             * Fires when the timeline has loaded.
             * @param {Rally.alm.ui.timeline.PortfolioItemTimeline} this
             */
            'load',
            /**
             * @event
             * Fires when the type combobox changes.
             * @param {Rally.alm.ui.timeline.PortfolioItemTimeline} this
             */
            'typeChange'
        );
        this.on('afterrender', this._onAfterRender, this);

        if (this.getFullScreen()) {
            Ext.EventManager.onWindowResize(this._resizeTimelineToFit, this);
        }
    },

    /**
     * Resize the timeline to fill the available area when the window resizes
     */
    _resizeTimelineToFit:function (windowWidth, windowHeight) {

        /* don't let the timeline shrink away to nothing on small resolutions */
        var minHeight = 250;

        if (!this.timeline || !this.timeline.el) {
            return;
        }

        if (!Ext.isDefined(windowWidth)) {
            windowWidth = Ext.getBody().getWidth();
        }
        if (!Ext.isDefined(windowHeight)) {
            windowHeight = Ext.getBody().getHeight();
        }

        var timelineRegion = Ext.util.Region.getRegion(this.timeline.el);

        var legendHeight = this.down('#timelineLegend').getHeight();

        //need to know the footer height to know how much space we have
        var footerHeight = Ext.get('footer').getHeight();
        var devFooter = Ext.get('devFooter');
        if (devFooter) {
            footerHeight += devFooter.getHeight();
        }

        var height = windowHeight - timelineRegion.top - legendHeight - footerHeight;

        if (height < minHeight) {
            height = minHeight;
        }

        this.timeline.setHeight(height);

        this.timeline.setWidth(windowWidth - 20);

    },

    _onAfterRender:function () {
        this.typeComboBox = this._createTypeComboBox();

        
//        this.getEl().on('click', function (event, el) {
//            el = Ext.get(el);
//            var record = this._getRecordFor(el, this.timeline.getSchedulingView());
//            Ext.create('Rally.ui.popover.PercentDonePopover', {
//                target: el,
//                percentDoneData: record.data,
//                percentDoneName: 'PercentDoneByStoryCount',
//                piRef: record.data._ref,
//                viewportPadding: [15,25,15,215]
//            });
//        }, this, {
//            delegate: '.sch-gantt-baseline-item'
//        });
    },

    _onModelsRetrieved:function (models) {
        this.models = models;
        this._createHeader();
        this._updateTimelineData();
        this._createLegend();
    },

    _createHeader: function(){
        var items = [{
            xtype: 'component',
            flex: 1
        }];

        items = items.concat(this._createZoomComponentItems());

        items.push(this.typeComboBox);

        var header = Ext.create('Ext.container.Container', {
            itemId: 'timelineHeader',
            items: items,
            layout: {
                type: 'hbox',
                align: 'middle'
            }
        });

        this.add(header);
    },

    _createLegend: function(){

        var tpl = Ext.create('Ext.XTemplate',
                '<b><span class="legend-text">Legend</span></b>',
                '<div><span class="legend-item planned"></span><span class="legend-text">Planned</span></div>',
                '<div><span class="legend-item" style="background-color: {late-color}"></span><span class="legend-text">Late</span></div>',
                '<div><span class="legend-item" style="background-color: {at-risk-color}"></span><span class="legend-text">At Risk</span></div>',
                '<div><span class="legend-item" style="background-color: {on-track-color}"></span><span class="legend-text">On Track</span></div>',
                '<div><span class="legend-item" style="background-color: {complete-color}"></span><span class="legend-text">Complete</span></div>'
        );

        this.add({
            xtype: 'component',
            itemId: 'timelineLegend',
            cls: 'timelineLegend',
            renderTpl: tpl,
            renderData: {
                'late-color': Rally.util.HealthColorCalculator.colors.red.hex,
                'at-risk-color': Rally.util.HealthColorCalculator.colors.yellow.hex,
                'on-track-color': Rally.util.HealthColorCalculator.colors.green.hex,
                'complete-color': Rally.util.HealthColorCalculator.colors.gray.hex
            }
        });
    },

    _createZoomComponentItems: function() {
        return [
            {
                xtype: 'label',
                text: 'Zoom',
                cls: 'rui-label'
            },
            {
                xtype: 'rallybuttonslider',
                cls: 'zoom-component',
                itemId:'zoomButtonSlider',
                sliderConfig:{
                    value:this.getSliderValueFromZoom(this.getZoomLevel()),
                    increment:1,
                    minValue:0,
                    maxValue:this.zoomLevels.length-1,//0 based
                    useTips:false,
                    listeners:{
                        change:function (slider, newValue) {
                            this.zoom(newValue);
                        },
                        scope: this
                    }
                }
            }
        ];
    },

    /**
     * Sets the zoom slider without firing the changed event
     * @param zoom{Number/String}
     */
    setZoomSliderValue:function(zoom){
        if (!this.rendered) {
            return;
        }
        var zoomIndex = Ext.isString(zoom)?this.getSliderValueFromZoom(zoom):zoom;
        var slider = this.down("#zoomButtonSlider");
        if (!slider) {
            return;
        }

        var originalValue = slider.getValue();

        slider.suspendEvents();
        slider.setValue(zoomIndex);
        slider.resumeEvents();

        if(originalValue === slider.getValue()){
            this.zoom(zoomIndex);
        }

    },

    setZoomLevel: function (zoomLevel) {
        this.zoomLevel = zoomLevel || this.getDefaultZoomLevel();
        this.setZoomSliderValue(this.zoomLevel);
    },

    getZoomLevel: function () {
        return this.zoomLevel || this.getDefaultZoomLevel();
    },
    _createTypeComboBox: function() {        
        var typeComboBox = Ext.create('Ext.container.Container',{ tpl: " <tpl>{Name}</tpl>"});
        
        Ext.create('Rally.data.wsapi.Store',{
            model: 'TypeDefinition',
            sorters:{
                property:'Ordinal',
                direction:'Asc'
            },
            limit: 1,
            pageSize: 1,
            filters: [
                {
                    property: 'Parent.Name',
                    operator: '=',
                    value: 'Portfolio Item'
                },
                {
                    property: 'Creatable',
                    operator: '=',
                    value: 'true'
                }
            ],
            autoLoad: true,
            listeners: {
                scope: this,
                load: function(store, types){
                    var selectedType = types[0];
                    
                    var typeNames = [];
                    Ext.each(types, function(value) {
                        typeNames.push(value.get('TypePath'));
                    });
                    
                    Rally.data.ModelFactory.getModels({
                        types : typeNames,
                        context: this.context,
                        success: this._onModelsRetrieved, scope:this
                    });
                    
                    typeComboBox.update(selectedType.getData());
                    typeComboBox.getRecord = function() { return selectedType; };
                    typeComboBox.getValue = function() { return typeNames[0]; };                    
                }
            }
        });
        
        return typeComboBox;
    },

    _getTypeRecordFromComboBox: function() {
        return this.typeComboBox.getRecord();
    },

    _onTypeSelect:function(){
        this.fireEvent('typeChange', this.getSelectedType());
        this._updateTimelineData();
    },

    _updateTimelineData: function() {
        if (this.timeline) {
            this.timeline.hide();
            this.timeline.destroy();
        }
        this._createTimeline();
    },

    _createTimeline: function() {
        //this.timeline = Ext.create('Rally.alm.ui.timeline.Timeline', this._getTimelineConfig());
        this.timeline = Ext.create('DependencyTimeline', this._getTimelineConfig());
        window.tl=this.timeline;
        this.insert(1, this.timeline);
    },

    _buildFilter:function () {
        var filters = [
            {
                property:this.estimatedStartDateField,
                operator:'!=',
                value:'null'
            },
            {
                property:this.estimatedEndDateField,
                operator:'!=',
                value:'null'
            },
            {
                property:this.estimatedEndDateField,
                operator:'>=',
                value:Rally.util.DateTime.format(this.taskStoreConfig.startDate, 'yyyy-MM-dd')
            },
            {
                property:this.estimatedStartDateField,
                operator:'<=',
                value:Rally.util.DateTime.format(this.taskStoreConfig.endDate, 'yyyy-MM-dd')
            },
            this._getTypeFilter()
        ];

        if (this.customQueryString) {
            try {
                filters.push(Rally.data.wsapi.Filter.fromQueryString(this.customQueryString));
            } catch (e) {
                Rally.ui.notify.Notifier.showError({
                    message: e.message
                });
            }
        }

        return filters;
    },

    _buildDrillDownFilter:function () {
        return [{
            property:'Parent',
            operator:'=',
            value:Rally.util.Ref.getRelativeUri(this._expandedNode.get('_ref'))
        }];
    },

    _getCurrentFilter:function () {
        return this._expandedNode ? this._buildDrillDownFilter() : this._buildFilter();
    },

    _getCurrentFetch:function () {
        var fetch = [
            'Name',
            this.estimatedStartDateField,
            this.estimatedEndDateField,
            this.actualStartDateField,
            this.actualEndDateField,
            this.piTypeField,
            this.piTypeOrdinalValueField,
            'Workspace',
            'FormattedID',
            'PercentDoneByStoryCount',
            'PercentDoneByStoryPlanEstimate'
        ];


        var record = !this._expandedNode ? this._getTypeRecordFromComboBox() : this._getTypeRecordBelowCurrentlyExpandedNode();
        if(record && record.get(this.piTypeOrdinalValueField) > 0) {
            fetch.push(this.childCountField);
        }

        return fetch;
    },


    _getTypeRecordAtOrdinal: function(ordinal) {
       return this.typeComboBox.findRecord(this.piTypeOrdinalValueField, ordinal);
    },

    _getTaskModelForExpandedType: function() {
        return Rally.alm.ui.timeline.TaskModelFactory.getTaskModel({
            wsapiModel: this._getModelBelowExpandedNode()
        });
    },

    _getModelBelowExpandedNode: function() {
        return this._getModelForTypeRecord(this._getTypeRecordBelowCurrentlyExpandedNode());
    },

    _getModelForTypeRecord: function(record) {
        return this.models[record.get('TypePath')];
    },

    _getModelForCurrentType: function() {
        return this._getModelForTypeRecord(this._getTypeRecordFromComboBox());
    },

    _getTypeRecordBelowCurrentlyExpandedNode : function() {
        return this._getTypeRecordAtOrdinal(this._getCurrentlyExpandedNodeOrdinal() - 1);
    },

    _getCurrentlyExpandedNodeOrdinal: function() {
        return this._expandedNode.get('PortfolioItemType').Ordinal;
    },

    _updateStoreModelWithCurrentlyExpandedType: function(store) {
        this._updateStoreModel(store, this._getTaskModelForExpandedType());
    },

    _onBeforeStoreLoad:function (store, operation) {
        if(operation.node && operation.node.parentNode) {
            this._expandedNode = operation.node;
        }
        
        if(this._expandedNode) {
            this._updateStoreModelWithCurrentlyExpandedType(store);
        }

        operation.filters = this._getCurrentFilter();
        operation.fetch = this._getCurrentFetch();

        //Set context correctly for tree expand
        if (operation.node && operation.node.get('_ref')) {
            operation.context = operation.context || {};
            operation.context.project = null;

            if (this._expandedNode) {
                operation.context.workspace = '/workspace/' + Rally.util.Ref.getOidFromRef(this._expandedNode.get('Workspace')._ref);
            }
        }
    },

    //When the store is initialized with its model, the process of finding the root node decorates
    //the model with additional fields that the tree uses for display. As we move through the tree, the new model needs to be updated
    //with the additional fields (If you don't you get cherkberxes ermahgerd.)
    _updateStoreModel: function(store, model) {
        store.model = model;
        store.setProxy(model.proxy);
        store.getProxy().getReader().buildExtractors(true);
    },

    _onBeforeExpand:function (node) {
        this.fireEvent('beforeexpandnode', this);
    },

    _getTimelineConfig:function () {
        var taskStoreConfig = Ext.apply({
            model:this._getModelForCurrentType(),
            fetch:this._getCurrentFetch(),
            listeners:{
                beforeload:this._onBeforeStoreLoad,
                beforeexpand:this._onBeforeExpand,
                load: this._onTimelineLoaded,
                scope:this
            }
        }, this.taskStoreConfig);

        var projectName = '',
            scopeUp = '',
            scopeDown = '';

        if (this.context) {
            projectName = this.context.projectName;
            scopeUp = this.context.projectScopeUp;
            scopeDown = this.context.projectScopeDown;
        } else {
            var scope = Rally.getScope();
            if(scope.project) {
                projectName = scope.project.Name;
                scopeUp = scope.up;
                scopeDown = scope.down;
            }
        }

        return {
            plugins: new Gnt.plugin.Printable({
                mainTpl: Ext.create('Rally.alm.ui.timeline.PrintTimelineTemplate', {
                    projectName: projectName,
                    scopeUp: scopeUp,
                    scopeDown: scopeDown,
                    typeName: this.typeComboBox.rawValue
                })
            }),
            taskStoreConfig: taskStoreConfig,
            leftLabelField: '',
            baselineStartDateField: this.actualStartDateField,
            baselineEndDateField: this.actualEndDateField,
            startDateField : this.estimatedStartDateField,
            endDateField : this.estimatedEndDateField,
            childCountField: this.childCountField,
            columns: this._getColumnConfigs(),
            zoomLevel:this.getZoomLevel(),
            startDate: this.taskStoreConfig.startDate,
            endDate: this.taskStoreConfig.endDate,
            eventRenderer: function(taskRec){
                return {
                    cls: Rally.util.Test.toBrowserTestCssClass('estimated-bar', taskRec.get('ObjectID')),
                    basecls: Rally.util.Test.toBrowserTestCssClass('actual-bar', taskRec.get('ObjectID'))
                };
            },
            viewConfig: {
                loadMask: false
            },
            /**
             * View config for the Gantt Panel, and not the left tree panel
             */
            normalViewConfig: {
                emptyText: this._getEmptyText()
            },
            enableTaskDragDrop: false,
            enableDragCreation: false,
            enableDependencyDragDrop: false,
            resizeHandles: 'none',
            trackHeaderOver: false,
            listeners: {
                scope: this,
                taskclick: function(gantt,taskRecord,e,eOpts) {
                    //
                }
            }
        };
    },

    _getEmptyText: function() {
        var messageTpl = Ext.create('Ext.XTemplate', this.emptyTextTpl);
        var record = this._getTypeRecordFromComboBox();
        var message = messageTpl.apply({selectedType: record.get('Name')});
        var emptyTextMessage = Rally.ui.EmptyTextFactory.getEmptyTextFor(message);

        return emptyTextMessage;
    },

    _onTimelineLoaded: function(taskStore) {
        this.fireEvent('load', this, {});

        if (taskStore.getCount() === 0 && this.timeline.todayLinePlugin) {
            this.timeline.todayLinePlugin.setDisabled(true);
        }

        this._expandedNode = undefined;

        if (this.getFullScreen()) {
            this._resizeTimelineToFit();
        }

        if (Rally.BrowserTest) {
            Rally.BrowserTest.publishComponentReady(this);
        }
    },

    _getRecordFor:function(el, view){
        var row = el.up('tr');
        return view.getRecord(row);
    },

    _getTypeFilter:function () {
        var record = this._getTypeRecordFromComboBox();
        return {
            property:this.piTypeField,
            operator:'=',
            value:Rally.util.Ref.getRelativeUri(record.get('_ref'))
        };
    },

    _getColumnConfigs:function () {
        return [
            {
                xtype:'treecolumn',
                header:"Name",
                dataIndex:'Name',
                width: 200,
                menuDisabled:true,
                renderer:function (value, metaData,record) {
                    return Ext.create('Ext.XTemplate',
                            '<a href="{[this.createDetailUrl(values)]}" target="_top">{FormattedID}:</a> {Name}',
                            {
                                createDetailUrl:function (values) {
                                    return Rally.nav.Manager.getDetailUrl(values);
                                }
                            }).apply(record.data);
                }
            }
        ];
    },

    setWidth:function (w) {
        this.callParent(arguments);
        if (this.timeline) {
            this.timeline.setWidth(w);
        }
    },

    getSelectedZoomLevel:function () {
        return this.timeline.getZoomLevel();
    },

    getDefaultZoomLevel: function(){
        return 'monthAndYear';
    },

    getSelectedType:function () {
        return this.typeComboBox.getValue();
    },

    zoom:function(zoom){
        this.timeline.zoom(zoom);
    },

    getSliderValueFromZoom:function(zoom){
        var sliderValue = this.zoomLevels.indexOf(zoom.preset || zoom);
        //if not found return a reasonable default
        return Math.max(sliderValue,0);
    }
});
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Ext.Component',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
     title: "Build Information",
    
    renderTpl: "<div id='{id}-infolinkWrap' class='tsinfolink'>--</div>",

    initComponent: function() {
        this.callParent(arguments);
       
    },
    
    onRender: function() {
        this.callParent(arguments);
        this.mon(this.el,'click',this.onClick,this);
    },
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
    
        return chk;
    },
    _checkChecksum: function(container) {
        var me = this;
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    if ( CHECKSUM !== me._generateChecksum(text) ) {
                        console.log("Checksums don't match!");
                        if ( me.dialog ) {
                            me.dialog.add({xtype:'container',html:'Checksums do not match'});
                        }
                    }
                }
            }
        });
    },
    onClick: function(e) {
        var me = this;
        this._checkChecksum(this);
        
        var dialog_items = [];
        
        if ( this.informationHtml ) {
            dialog_items.push({
                xtype:'container',
                html: this.informationHtml
            });
        }
                
        dialog_items.push({
            xtype:'container',
            html:"This app was created by the Rally Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            dialog_items.push({
                xtype:'container',
                html:'Build date/time: ' + APP_BUILD_DATE
            });
        }
        
        if (this.dialog){this.dialog.destroy();}
        this.dialog = Ext.create('Rally.ui.dialog.Dialog',{
            defaults: { padding: 5, margin: 5 },
            closable: true,
            draggable: true,
            title: me.title,
            items: dialog_items
        });
        this.dialog.show();
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

Ext.define('Rally.technicalservices.dialog.TaskDialog',{
    extend: 'Rally.ui.dialog.Dialog',
    alias:  'widget.tstaskdialog',
    config: {
        /*
         * @cfg {Model} 
         * 
         * The task record shown on the timeline
         */
        artifact: null
    },
    items: { 
        xtype:'panel',
        border:false,
        items: [
            {
                xtype:'container',
                itemId:'form_box',
                layout:'fit',
                width: 300
            }
        ]
    },
   constructor: function(config) {
        this.mergeConfig(config);

        this.callParent([this.config]);
    },

    initComponent: function() {
        this.callParent(arguments);
        this.addEvents(
                /**
                 * @event updateClicked
                 * Fires when if the update button is clicked
                 * @param {Rally.technicalservices.dialog.TaskDialog} this
                 * @param {Rally.domain.WsapiModel} record
                 * @param {String} planned_start_date (in ISO)
                 * @param {String} planned_end_date (in ISO)
                 */
                'updateClicked'
        );

        this.addCls('chooserDialog');

        this._buildForm();
        this._buildButtons();
    },
    _buildForm: function() {
        if ( this.artifact ) { 
            this.planned_start_date = this.artifact.get('PlannedStartDate');
            this.planned_end_date = this.artifact.get('PlannedEndDate');
            this.down('panel').add({
                xtype:'rallydatefield',
                value: this.planned_start_date,
                fieldLabel: 'Planned Start Date',
                labelAlign: 'top',
                listeners: {
                    scope: this,
                    change: function(db, new_value) {
                        this.planned_start_date = new_value;
                    }
                }
            });
            
            this.down('panel').add({
                xtype:'rallydatefield',
                value: this.planned_end_date,
                fieldLabel: 'Planned End Date',
                labelAlign: 'top',
                listeners: {
                    scope: this,
                    change: function(db, new_value) {
                        this.planned_end_date = new_value;
                    }
                }
            });
        } else {
            this.down('panel').add({
                xtype:'container',
                html: 'Artifact not supplied'
            });
        }
        
    },
    _buildButtons: function() {
        this.down('panel').addDocked({
            xtype: 'toolbar',
            dock: 'bottom',
            padding: '0 0 10 0',
            layout: {
                type: 'hbox',
                pack: 'center'
            },
            ui: 'footer',
            items: [
                {
                    xtype: 'rallybutton',
                    text: 'Update',
                    scope: this,
                    userAction: 'clicked done in dialog',
                    handler: function() {
                        if ( this.planned_start_date > this.planned_end_date ) {
                            alert("The planned end date must be after the planned start date" );
                        } else {
                            this.fireEvent('updateClicked', this, this.artifact, this.planned_start_date, this.planned_end_date);
                            this.close();
                        }
                    }
                },
                {
                    xtype: 'rallybutton',
                    text: 'Cancel',
                    cls: 'secondary small',
                    handler: this.close,
                    scope: this,
                    ui: 'link'
                }
            ]
        });

    }
});
Ext.define('CustomApp', {
    extend: 'Rally.app.App',
    componentCls: 'app',
    logger: new Rally.technicalservices.Logger(),
    items: [
        {xtype:'container',itemId:'message_box',tpl:'Hello, <tpl>{_refObjectName}</tpl>'},
        {xtype:'container',itemId:'display_box'} 
        /*,
        {xtype:'tsinfolink'}
        */
    ],
    launch: function() {
        // this.down('#message_box').update(this.getContext().getUser());
        var me = this;

        me.down('#display_box').add({
            xtype: 'almportfolioitemtimeline',
            context: me.getContext(),
            listeners: {
                scope: this,
                taskclick: function( gantt, taskRecord, e, eOpts ) {
                    this.logger.log("clicked ", taskRecord);
                    this.showDialog(taskRecord,gantt);
                }
            }
        });
    },
    showDialog: function(taskRecord,gantt){
        this.logger.log('showDialog ', taskRecord.get('PlannedStartDate'),taskRecord.get('PlannedEndDate'));
        if ( this.dialog ) { this.dialog.destroy(); }
        this.dialog = Ext.create('Rally.technicalservices.dialog.TaskDialog',{
            artifact: taskRecord,
            title: taskRecord.get('FormattedID') + ": " + taskRecord.get('Name'),
            listeners: {
                scope: this,
                updateClicked: function(dialog, artifact, planned_start_date, planned_end_date) {
                    this.logger.log("update", planned_start_date, planned_end_date);
                    artifact.set('PlannedStartDate', Rally.util.DateTime.toIsoString(planned_start_date));
                    artifact.set('PlannedEndDate', Rally.util.DateTime.toIsoString(planned_end_date));
                    artifact.save();
                }
            }
        });
        this.dialog.show();
    }
});

            
               Rally.launchApp('CustomApp', {
                   name: 'Timeline With Dependencies'
               });
        });
    </script>
    
    <link rel="stylesheet" type="text/css" href="https://rally1.rallydev.com/slm/pack/combined.css.h-276745884.pack">
    
    <!--
    <link rel="stylesheet" type="text/css" href="/slm/pack/combined.css.h-458667689.pack">
    <link rel="stylesheet" type="text/css" href="/slm/pack/combined.css.h-540919694.pack">
    <link rel="stylesheet" type="text/css" href="/slm/pack/combined.css.h482711781.pack">
    -->
    <link rel="stylesheet" type="text/css" href="/slm/js-lib/rui/builds/rui/resources/css/rui-fonts.css">

    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width:5%;
}

.x-unselectable {
    user-select: none;
    -o-user-select: none;
    -ms-user-select: none;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
    cursor: default;
}

.x-grid-cell-inner {
    white-space: nowrap;
    zoom: 1;
}

.x-tree-elbow-img, .x-tree-icon {
    background-repeat: no-repeat;
    background-position: 0 center;
    vertical-align: top;
}

.sch-ganttpanel .x-tree-panel .x-tree-icon-parent, .sch-ganttpanel .x-tree-panel .x-tree-icon-leaf {
    background: none;
    width: 0;
}

.sch-ganttpanel .sch-gantt-label {
    color: #333 !important;
}

.sch-gantt-label {
    color: #999;
    height: 16px;
    white-space: nowrap;
}

.sch-gantt-progress-bar {
    background: #7971e2 url(/slm/js-lib/ext-gantt/2.2.15/resources/images/transp-1px.png) repeat-x left top;
    overflow: hidden;
    height: 100%;
}

.sch-ganttpanel .sch-timelineview .x-grid-row .x-grid-cell.sch-timetd {
    border-top: none !important;
    border-right: none !important;
    border-bottom: 1px solid #c6c6c6 !important;
    border-left: none !important;
    height: 35px;
}

td.sch-timetd .x-grid-cell-inner {
    position: relative;
    padding-left: 0;
    padding-right: 0;
    cursor: default;
    overflow: visible;
}

.sch-ganttpanel .x-tree-panel .x-grid-body table td {
    height: 35px;
}
    </style>

</head>
<body></body>
</html>